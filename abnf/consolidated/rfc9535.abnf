jsonpath-query = root-identifier segments
segments = *(S segment)
B = %d32 / %d9 / %d10 / %d13
S = *B
root-identifier = "$"
selector = name-selector / wildcard-selector / slice-selector / index-selector / filter-selector
name-selector = string-literal
string-literal = %d34 *double-quoted %d34 / %d39 *single-quoted %d39
double-quoted = unescaped / %d39 / ESC %d34 / ESC escapable
single-quoted = unescaped / %d34 / ESC %d39 / ESC escapable
ESC = %d92
unescaped = %x20-21 / %x23-26 / %x28-5b / %x5d-d7ff / %xe000-ffff / %xd800-dbff %xdc00-dfff
escapable = %d98 / %d102 / %d110 / %d114 / %d116 / "/" / "\" / (%d117 hexchar)
hexchar = non-surrogate / (high-surrogate "\" %d117 low-surrogate)
non-surrogate = ((DIGIT / "A" / "B" / "C" / "E" / "F") 3HEXDIG) / ("D" %x30-37 2HEXDIG)
high-surrogate = "D" ("8" / "9" / "A" / "B") 2HEXDIG
low-surrogate = "D" ("C" / "D" / "E" / "F") 2HEXDIG
HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
wildcard-selector = "*"
index-selector = int
int = "0" / (["-"] DIGIT1 *DIGIT)
DIGIT1 = %x31-39
slice-selector = [start S] ":" S [end S] [":" [S step]]
start = int
end = int
step = int
filter-selector = "?" S logical-expr
logical-expr = logical-or-expr
logical-or-expr = logical-and-expr *(S "||" S logical-and-expr)
logical-and-expr = basic-expr *(S "&&" S basic-expr)
basic-expr = paren-expr / comparison-expr / test-expr
paren-expr = [logical-not-op S] "(" S logical-expr S ")"
logical-not-op = "!"
test-expr = [logical-not-op S] (filter-query / function-expr)
filter-query = rel-query / jsonpath-query
rel-query = current-node-identifier segments
current-node-identifier = "@"
comparison-expr = comparable S comparison-op S comparable
literal = number / string-literal / true / false / null
comparable = literal / singular-query / function-expr
comparison-op = "==" / "!=" / "<=" / ">=" / "<" / ">"
singular-query = rel-singular-query / abs-singular-query
rel-singular-query = current-node-identifier singular-query-segments
abs-singular-query = root-identifier singular-query-segments
singular-query-segments = *(S (name-segment / index-segment))
name-segment = ("[" name-selector "]") / ("." member-name-shorthand)
index-segment = "[" index-selector "]"
number = (int / "-0") [frac] [exp]
frac = "." 1*DIGIT
exp = "e" ["-" / "+"] 1*DIGIT
true = %x74
false = %x66
null = %x6e
function-name = function-name-first *function-name-char
function-name-first = LCALPHA
function-name-char = function-name-first / "_" / DIGIT
LCALPHA = %x61-7a
function-expr = function-name "(" S [function-argument *(S "," S function-argument)] S ")"
function-argument = literal / filter-query / logical-expr / function-expr
segment = child-segment / descendant-segment
child-segment = bracketed-selection / ("." (wildcard-selector / member-name-shorthand))
bracketed-selection = "[" S selector *(S "," S selector) S "]"
member-name-shorthand = name-first *name-char
name-first = ALPHA / "_" / %x80-d7ff / %xe000-ffff / %xd800-dbff %xdc00-dfff
name-char = name-first / DIGIT
DIGIT = %x30-39
ALPHA = %x41-5a / %x61-7a
descendant-segment = ".." (bracketed-selection / wildcard-selector / member-name-shorthand)
normalized-path = root-identifier *(normal-index-segment)
normal-index-segment = "[" normal-selector "]"
normal-selector = normal-name-selector / normal-index-selector
normal-name-selector = %d39 *normal-single-quoted %d39
normal-single-quoted = normal-unescaped / ESC normal-escapable
normal-unescaped = %x20-26 / %x28-5b / %x5d-d7ff / %xe000-ffff / %xd800-dbff %xdc00-dfff
normal-escapable = %d98 / %d102 / %d110 / %d114 / %d116 / "'" / "\" / (%d117 normal-hexchar)
normal-hexchar = "0" "0" (("0" %x30-37) / ("0" %d98) / ("0" %x65-66) / ("1" normal-HEXDIG))
normal-HEXDIG = DIGIT / %x61-66
normal-index-selector = "0" / (DIGIT1 *DIGIT)